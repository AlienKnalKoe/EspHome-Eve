esphome:
  name: eve-robot
  friendly_name: Eve Robot Girl
  min_version: 2025.11.0
  includes:
    - sd_driver.h
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_SPIRAM_RODATA: y

psram:
  mode: octal
  speed: 80MHz



# === GLOBALS ===
globals:
  - id: question_active
    type: bool
    initial_value: 'false'
  - id: game_active
    type: bool
    initial_value: 'false'
  - id: current_word
    type: std::string
    initial_value: '""'
  - id: display_word
    type: std::string
    initial_value: '""'
  - id: mistake_count
    type: int
    initial_value: '0'

logger:
  level: INFO
api:
ota:
  - platform: esphome
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# === FONT ===
font:
  - file: "gfonts://JetBrains Mono"
    id: robot_font
    size: 35
    glyphs: >-
      !"%()+=,-_. \|/0123456789:;?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzéëèỏ'

# === IMAGES ===
image:
  - file: "images/neutral.png"
    id: img_neutral
    type: RGB565
  - file: "images/eyes_closed.png"
    id: img_eyes_closed
    type: RGB565
  - file: "images/happy.png"
    id: img_happy
    type: RGB565
  - file: "images/surprised.png"
    id: img_surprised
    type: RGB565
  - file: "images/mouth_closed.png"
    id: img_mouth_closed
    type: RGB565
  - file: "images/mouth_open1.png"
    id: img_mouth_open1
    type: RGB565
  - file: "images/mouth_open2.png"
    id: img_mouth_open2
    type: RGB565
  - file: "images/mouth_open3.png"
    id: img_mouth_open3
    type: RGB565
  - file: "images/mini.png"
    id: img_mini_neutral
    type: RGB565
  - file: "images/angry_redalert.png"
    id: img_angry_redalert
    type: RGB565

# === HARDWARE ===
output:
  - platform: ledc
    id: backlight_pwm
    pin: GPIO38
    frequency: 12000Hz
    min_power: 0.08

light:
  - platform: monochromatic
    name: "Brightness"
    id: display_backlight
    output: backlight_pwm
    restore_mode: ALWAYS_ON

spi:
  - id: display_init_spi
    interface: software
    clk_pin: GPIO48
    mosi_pin: GPIO47
    miso_pin: GPIO41
    #interface: software

display:
  - platform: mipi_rgb
    model: GUITION-4848S040
    id: my_display
    spi_id: display_init_spi
    update_interval: never
    auto_clear_enabled: false
    rotation: 90 

i2c:
  - id: i2c_bus
    sda: GPIO19
    scl:
      number: GPIO45
      ignore_strapping_warning: true

touchscreen:
  - platform: gt911
    id: gt911_touch
    display: my_display
    i2c_id: i2c_bus
    address: 0x5D
    transform:
      swap_xy: true
      mirror_x: true
      mirror_y: false
    on_touch:
      then:
        - light.turn_on:
            id: display_backlight
            brightness: 100%
        - script.execute: idle_dimmer_script

# === HARDWARE: SD CARD (SPI MODE) ===
sensor:
  - platform: template
    name: "SD Card Controller"
    id: sd_status
    lambda: |-
      static SDCustom* my_sd = nullptr;
      if (my_sd == nullptr) {
          my_sd = new SDCustom();
          my_sd->setup();
      }
      return 1.0; 
    update_interval: never # We only want it to run once at boot

# === LVGL UI ===
lvgl:
  buffer_size: 40%
  color_depth: 16
  pages:
    - id: main_robot
      widgets:
        - image:
            id: face
            src: img_neutral
            align: CENTER
            
        - obj:
            id: face_touch_zone
            width: 350
            height: 350
            align: CENTER
            bg_opa: 0
            border_width: 0
            on_click:
              - if:
                  condition:
                    lambda: 'return !id(question_active) && !id(game_active);'
                  then:
                    - if:
                        condition:
                          script.is_running: eve_talks
                        then:
                          - script.stop: eve_talks
                          - lvgl.widget.hide: speech_bubble
                          - script.execute:
                              id: eve_talks
                              message: "Stop it! Leave me alone!"
                              duration_ms: 2000
                              use_happy_face: false
                          - delay: 2100ms
                          - lvgl.image.update: { id: face, src: img_angry_redalert }
                          - delay: 2s
                          - lvgl.image.update: { id: face, src: img_neutral }
                        else:
                          - lvgl.widget.hide: speech_bubble
                          - script.execute:
                              id: eve_talks
                              message: "Hey! That tickles!"
                              duration_ms: 2500
                              use_happy_face: true
        
        # Settings Button
        - button:
            id: secret_settings_btn
            width: 120
            height: 120
            align: BOTTOM_RIGHT
            bg_opa: 0%      # Invisible
            border_opa: 0%  # Invisible
            shadow_width: 0
            on_long_press:
              - lvgl.page.show: settings_page
        - obj:
            id: speech_bubble
            width: 380
            height: 120
            align: TOP_MID
            y: 20
            hidden: true
            bg_color: 0xFFFFFF
            radius: 20
            border_width: 3
            widgets:
              - label:
                  id: speech_text
                  text: ""
                  align: CENTER
                  width: 340
                  text_font: robot_font

        - button:
            id: btn_yes
            width: 70
            height: 70
            align: BOTTOM_RIGHT
            x: -60
            y: -60
            hidden: true
            bg_color: 0x2ECC71
            radius: 12
            on_click:
              - script.execute: { id: handle_choice, choice: true }
            widgets:
              - label: {text: "YES", align: CENTER}

        - button:
            id: btn_no
            width: 70
            height: 70
            align: BOTTOM_LEFT
            x: 60
            y: -60
            hidden: true
            bg_color: 0xE74C3C
            radius: 12
            on_click:
              - script.execute: { id: handle_choice, choice: false }
            widgets:
              - label: {text: "NO", align: CENTER}

    # SETTINGS PAGE (Separated from Main Robot)
    - id: settings_page
      bg_color: 0x1A1A1A
      widgets:
        - label:
            text: "SETTINGS"
            align: TOP_MID
            y: 20
            text_font: robot_font
            text_color: 0xFFFFFF
        - button:
            align: CENTER
            y: 0
            width: 250
            height: 50
            widgets: [{label: {text: "View SD Files"}}]
            on_click:
              - lvgl.page.show: sd_list_page
              - lambda: |-
                  // 1. Get the list from our driver
                  // We cast the sensor to our SDCustom class
                  auto* controller = (SDCustom*)id(sd_status);
                  std::string files = controller->get_file_list();
                  
                  // 2. THE FIX: No type names (like lv_obj_t), just the IDs
                  lv_label_set_text(id(file_list_label), files.c_str());

        - button:
            width: 200
            height: 50
            align: BOTTOM_MID
            y: -20
            on_click:
              - lvgl.page.show: main_robot
            widgets:
              - label: {text: "BACK"}
    - id: sd_list_page
      # This allows the page to move if the text is long
      scrollable: true 
      widgets:
        - label:
            text: "Files on SD Card:"
            align: TOP_MID
            y: 10
            text_font: robot_font
        
        - label:
            id: file_list_label
            text: "Loading..."
            align: TOP_LEFT
            x: 20
            y: 50
            width: 440 
            text_font: robot_font

        - button:
            width: 60
            height: 60
            align: TOP_LEFT
            widgets: [{label: {text: "<"}}]
            on_click:
              - lvgl.page.show: settings_page          

    # GAME PAGE (Separated from Main Robot)
    - id: game_page
      bg_color: 0x000000
      widgets:
        - image:
            id: mini_face
            src: img_mini_neutral
            align: TOP_RIGHT
            x: -10
            y: 10
        - label:
            id: hangman_visual
            text: ""
            align: TOP_MID
            y: 20
            text_font: robot_font
            text_color: 0xFF0000
        - label:
            id: word_label
            text: ""
            align: CENTER
            y: -40
            text_font: robot_font
            text_color: 0xFFFFFF
        - keyboard:
            id: game_kb
            width: 440
            height: 180
            align: BOTTOM_MID
            y: -10
            on_value:
              then:
                - lambda: |-
                    if(lv_event_get_code(event) == LV_EVENT_VALUE_CHANGED) {
                      uint16_t btn_id = lv_btnmatrix_get_selected_btn(id(game_kb)->obj);
                      if(btn_id != LV_BTNMATRIX_BTN_NONE) {
                        const char* btn_text = lv_btnmatrix_get_btn_text(id(game_kb)->obj, btn_id);
                        if(btn_text != nullptr && strlen(btn_text) == 1) {
                          id(process_guess).execute(btn_text);
                        }
                      }
                    }
        - button:
            id: btn_exit_game
            width: 100
            height: 50
            align: TOP_LEFT
            x: 10
            y: 10
            bg_color: 0x555555
            on_click:
              - lvgl.page.show: main_robot
              - globals.set: { id: game_active, value: 'false' }
            widgets:
              - label: {text: "EXIT"}
        - button:
            id: hangman_restart_btn
            align: BOTTOM_MID
            y: -20
            # hidden: true # Start hidden
            widgets: [{label: {text: "Play Again"}}]
            on_click:
              - script.execute: start_new_game # Your script that picks a new word
              # - lambda: 'lv_obj_add_flag(id(hangman_restart_btn), LV_OBJ_FLAG_HIDDEN);'     

# === SCRIPTS ===
script:
  - id: handle_choice
    parameters:
      choice: bool
    mode: restart
    then:
      - script.stop: eve_ask_question
      - globals.set: { id: question_active, value: 'false' }
      - lvgl.widget.hide: btn_yes
      - lvgl.widget.hide: btn_no
      - if:
          condition:
            lambda: 'return choice;'
          then:
            - script.execute:
                id: eve_talks
                message: "Great! Let's play!"
                duration_ms: 2000
                use_happy_face: true
            - delay: 2.1s
            - script.execute: start_hangman
          else:
            - script.execute:
                id: eve_talks
                message: "Maybe later then!"
                duration_ms: 2000
                use_happy_face: false

  - id: start_hangman
    then:
      - globals.set: { id: game_active, value: 'true' }
      - globals.set: { id: mistake_count, value: '0' }
      - lvgl.label.update: { id: hangman_visual, text: "" }
      - lambda: |-
          std::vector<std::string> words = {"ROBOT", "HAPPY", "CHIP", "SCREEN", "TALK", "SURPRISE", "LOVE", "ANGRY", "MINI", "ESPRESSO", "PYTHON", "CODE", "DISPLAY", "BUTTON", "SENSOR", "WIFI", "HOME", "FUTURE", "TECH", "GADGET"};
          std::string picked = words[rand() % words.size()];
          id(current_word) = picked;
          std::string hidden = "";
          for(char& c : picked) hidden += "_ ";
          id(display_word) = hidden;
      - lvgl.label.update:
          id: word_label
          text: !lambda 'return id(display_word).c_str();'
      - lvgl.page.show: game_page

  - id: process_guess
    parameters:
      guess: string
    then:
      - lambda: |-
          std::string picked = id(current_word);
          std::string current_display = id(display_word);
          char input = std::toupper(guess[0]);
          bool found = false;
          
          for (size_t i = 0; i < picked.length(); i++) {
            if (picked[i] == input) {
              current_display[i * 2] = input;
              found = true;
            }
          }
          id(display_word) = current_display;
          
          if (!found) {
            id(mistake_count)++;
            lv_img_set_src(id(mini_face), id(img_mini_neutral).get_lv_img_dsc());
            
            // Stages with proper C++ escaping for backslashes
            const char* stages[] = {
            " ____\n |      \n |       \n_|_",
            " ____\n | ỏ   \n |       \n_|_",
            " ____\n |\\ỏ   \n |       \n_|_",
            " ____\n |\\ỏ/  \n |       \n_|_",
            " ____\n |\\ỏ/  \n |  |    \n_|_",
            " ____\n |\\ỏ/  \n |  |    \n_|_/",
            " ____\n |\\ỏ/  \n |  |    \n_|_/\"
          };
            if(id(mistake_count) <= 6) {
              lv_label_set_text(id(hangman_visual), stages[id(mistake_count)]);
            }
          } else {
            lv_img_set_src(id(mini_face), id(img_mini_neutral).get_lv_img_dsc());
          }
      - lvgl.label.update:
          id: word_label
          text: !lambda 'return id(display_word).c_str();'
      - delay: 800ms
      - lvgl.image.update: { id: mini_face, src: img_mini_neutral }
      - if:
          condition:
            lambda: |-
              bool win = (id(display_word).find('_') == std::string::npos);
              bool loss = (id(mistake_count) >= 6);
              
              if (win || loss) {
                id(game_active) = false;
                std::string msg = loss ? ("The word was: " + id(current_word)) : "You Won!";
                
                // Show final word and reveal the Play Again button
                lv_label_set_text(id(word_label), msg.c_str());
                lv_obj_clear_flag(id(hangman_restart_btn), LV_OBJ_FLAG_HIDDEN);
                
                id(eve_talks)->execute(msg + ". Play again?", 5000, win);
                return true; // Condition MET - triggers 'then'
              }
              return false; // Condition NOT met
          then:
            - delay: 8s
            - lvgl.page.show: main_robot

  - id: start_new_game
    then:
      - globals.set: { id: mistake_count, value: '0' }
      - lvgl.widget.hide: hangman_restart_btn
      - script.execute: start_hangman # This re-picks a word and resets the UI

  - id: eve_ask_question
    parameters:
      question: string
    mode: restart
    then:
      - globals.set: { id: question_active, value: 'true' }
      - lvgl.label.update:
          id: speech_text
          text: !lambda 'return question.c_str();'
      - lvgl.widget.show: speech_bubble
      - lvgl.widget.show: btn_yes
      - lvgl.widget.show: btn_no
      - lvgl.image.update: { id: face, src: img_surprised }
      - delay: 8s
      - if:
          condition:
            lambda: 'return id(question_active);'
          then:
            - lvgl.widget.hide: btn_yes
            - lvgl.widget.hide: btn_no
            - lvgl.widget.hide: speech_bubble
            - lvgl.image.update: { id: face, src: img_neutral }
            - globals.set: { id: question_active, value: 'false' }

  - id: eve_talks
    parameters:
      message: string
      duration_ms: int
      use_happy_face: bool
    mode: restart
    then:
      - if:
          condition: { lambda: 'return use_happy_face;' }
          then:
            - lvgl.image.update: { id: face, src: img_happy }
          else:
            - lvgl.image.update: { id: face, src: img_neutral }
      - lvgl.label.update:
          id: speech_text
          text: !lambda 'return message.c_str();'
      - lvgl.widget.show: speech_bubble
      - while:
          condition:
            lambda: |-
              static uint32_t start_t = 0;
              if (start_t == 0) start_t = millis();
              if (millis() - start_t > (uint32_t)duration_ms) {
                start_t = 0;
                return false;
              }
              return true;
          then:
            - lvgl.image.update: { id: face, src: img_mouth_open1 }
            - delay: 150ms
            - lvgl.image.update: { id: face, src: img_mouth_open2 }
            - delay: 150ms
            - lvgl.image.update: { id: face, src: img_mouth_open3 }
            - delay: 150ms
            - lvgl.image.update: { id: face, src: img_mouth_closed }
            - delay: 150ms
      - lvgl.widget.hide: speech_bubble
      - lvgl.image.update: { id: face, src: img_neutral }

  - id: idle_dimmer_script
    mode: restart
    then:
      - delay: 60s
      - light.control:
          id: display_backlight
          brightness: 10% # Low light (dimmed), not off
          transition_length: 2s
      - lvgl.image.update: { id: face, src: img_eyes_closed }

# === AUTOMATIONS ===
interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return !id(question_active) && !id(game_active);'
          then:
            - if:
                condition:
                  lambda: |-
                    static uint32_t last_blink = 0;
                    uint32_t now = millis();
                    if (now - last_blink < 4000) return false;
                    if (now - last_blink > 9000) { last_blink = now; return true; }
                    return (rand() % 100) < 20;
                then:
                  - lvgl.image.update: { id: face, src: img_eyes_closed }
                  - delay: 140ms
                  - lvgl.image.update: { id: face, src: img_neutral }

  - interval: 60s
    then:
      - if:
          condition:
            lambda: 'return !id(game_active) && (rand() % 100) < 25;'
          then:
            - script.execute:
                id: eve_ask_question
                question: "Shall we play a game?"